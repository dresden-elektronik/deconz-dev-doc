---
title: Device class
date: 2021-07-11

---

# Device class

This page serves as an overview of the `Device` class.

<mark>Work in Progress</mark>

[device.h](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/device.h) [device.cpp](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/device.cpp)

## Purpose

The `Device` class is a generic controller for a device which works on dynamic `Resource` and `ResourceItem` objects. The most important detail is that this class knows nothing about specific devices. Internally the class is driven by a state machine which reacts to events and can also emit events to the outside world.

The class isn't aware about sleeping end-devices or routers, the knowledge that a device is able to receive commands comes from *Awake* and *Poll Events* which are generated by external classes and command handlers.

## Dependencies

The class depends only on a few other classes and modules. 

- `Resource` as base class and to reference sub devices, which are just seen as Resource instances;
- `Event` to interact with other components and provide lose coupling;
- `deCONZ::Node` to access *Simple Descriptors* and *Node Descriptor*;
- [Device Access (DA)](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/device_access_fn.h) module to execute **abstract** named C++ parse, read and write functions which can be attached to a `ResourceItem`.  
  Examples: [IKEA KADRILJ DDF](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/devices/ikea/kadrilj_blind.json) and [state/on item](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/devices/generic/items/state_on_item.json);
- [ZDP](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/zdp/zdp.h) module to query ZDP descriptors during setup;
- [ZCL](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/zcl/zcl.h) module to query ZCL *Basic Cluster* attributes during setup.

![Device Dependencies](https://github.com/dresden-elektronik/deconz-rest-plugin-v2/raw/master/arch/diagrams/device_dependencies.png)

Note: There are no dependencies to `DeRestPlugin`, `RestNodeBase`, `Sensor` or `LightNode` classes, even `deCONZ::ApsController` is just an opaque pointer.
All the class sees, is a device which has sub devices as `Resource` and their `ResourceItems`.

## State Machine

TODO

Each state in [device.cpp](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/device.cpp) is internaly implemented as a function which acts on `Event` where the entry point is the `Device::handleEvent(Event)`. The current state is therefore just a function pointer to a state function.

```cpp
void DEV_InitStateHandler(Device *device, const Event &event);
void DEV_IdleStateHandler(Device *device, const Event &event);
void DEV_NodeDescriptorStateHandler(Device *device, const Event &event);
void DEV_ActiveEndpointsStateHandler(Device *device, const Event &event);
void DEV_SimpleDescriptorStateHandler(Device *device, const Event &event);
void DEV_BasicClusterStateHandler(Device *device, const Event &event);
void DEV_GetDeviceDescriptionHandler(Device *device, const Event &event);
void DEV_BindingHandler(Device *device, const Event &event);
void DEV_BindingTableVerifyHandler(Device *device, const Event &event);
void DEV_PollIdleStateHandler(Device *device, const Event &event);
void DEV_PollNextStateHandler(Device *device, const Event &event);
void DEV_PollBusyStateHandler(Device *device, const Event &event);
```

### High Level View

The following diagram shows the general flow of the state machine. Once the basic setup is done the device enters the *Operating/Idle State* which runs multiple states in parallel — as array of function pointers. Going back to *Init State* can be done at any time, for example when reloading the DDF file. For a already initialized device it takes 3–5&nbsp;milliseconds to go from *Init State* to *Operating/Idle State*.

Other than internal timeouts the timing of the state machine is controlled by events generated from the outside.

![Device State Machine](https://github.com/dresden-elektronik/deconz-rest-plugin-v2/raw/master/arch/diagrams/device_state_machine.png)

Diagram source: [device_bindings.puml](https://github.com/dresden-elektronik/deconz-rest-plugin-v2/blob/master/arch/diagrams/device_state_machine.puml)

#### Node Descriptor State

The following diagram shows how error handling for ZDP Requests is done in the `DEV_NodeDescriptorStateHandler()` state function, the same principle applies for Active Endpoints and Simple Descriptors states.

![Node Descriptor State](https://github.com/dresden-elektronik/deconz-rest-plugin-v2/raw/master/arch/diagrams/device_state_node_descriptor.png)

Diagram source: [device_state_node_descriptor.puml](https://github.com/dresden-elektronik/deconz-rest-plugin-v2/blob/master/arch/diagrams/device_state_node_descriptor.puml)

### Bindings Sub State Machine

ZDP binding and ZCL reporting configuration is maintained during the full life cycle of the device. If any error or fault happens the state machine recovers automatically and verifies the configuration.

In contrast to classic REST-API C++ code the state machine also detects changes in reporting configuration and is able to apply those.

Each device has it's own copy of binding and ZCL reporting configuration which allows us later to provide custom configuration on a per device base.

Discussion in [issues/6](https://github.com/dresden-elektronik/deconz-rest-plugin-v2/issues/6)

The configuration for bindings and ZCL reporting is specified in DDF files, for example: [ikea/gu10_ws_400lm_light.json](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/devices/ikea/gu10_ws_400lm_light.json).

![Binding State Machine](https://github.com/dresden-elektronik/deconz-rest-plugin-v2/raw/master/arch/diagrams/device_bindings.png)

Diagram source: [device_bindings.puml](https://github.com/dresden-elektronik/deconz-rest-plugin-v2/blob/master/arch/diagrams/device_bindings.puml)

## Relation to Device Description Files (DDF)

The `Device` class can only setup a few steps on its own like query ZDP descriptors and ZCL *Basic* Cluster attributes like modelid and manufacturer name. After that DDF files are used to setup the related sub resources.

This is done outside of the `Device` class by a [DDF Loader](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/device_descriptions.h). First a `Device` sends an `REventDDFInitRequest` event and waits, later on it receives an `REventDDFInitResponse` event, at that time all sub device `Resources` and `ResourceItems` are initialized and the `Device` class goes into *Operational/Idle* state.

![Device Description File (DDF) Init](https://github.com/dresden-elektronik/deconz-rest-plugin-v2/raw/master/arch/diagrams/device_init_ddf.png)


The [Device Compat](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/device_compat.cpp) (compatibility) module creates empty `Sensor` and `LightNode` objects and adds them to the respective plugin `sensors` and `nodes` containers. The [DDF Init](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/device_ddf_init.cpp) module then fills the `ResourceItems` based on the DDF and registers the `Resource` in the `Device`.

This way the "old" code as well as the `Device` can work side by side, albeit the `Device` doesn't know anything about this.

This process can be repeated at any time, for example during development of DDF files they can be reloaded on-the-fly without restarting deCONZ.

## Testing

Beside loose coupling, the minimal dependencies allow easier testing of the class and its behaviour of the state machine. In general all `Device` code is kept small and has no functions longer than two screen pages (if it does it is a bug). The goal is to get close to 100% test coverage, since internally mostly free standing functions are used this becomes straight forward. Each state and sub states can be tested in isolation as well as complete sequences like device pairing.

First steps to test the Device class behaviour can be found in [001-device-1.cpp](https://github.com/manup/deconz-rest-plugin/blob/device_descriptions/tests/001-device-1.cpp).

## State Change and REST API Functionality

TODO

