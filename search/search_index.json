{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Work in Progress This documentation describes the deCONZ C++ development around the newer so called Device code and Device Description Files (DDF). The discussion takes place in the deCONZ REST-API Plugin V2 repository on GitHub. Classic REST-API code \u00b6 The classic REST-API code handles sensors and lights in command handlers which iterate over respective containers. In these loops the code parses commands, often specific to devices based on their model identifier and take further actions. The ability to recover from errors and faults is limited and often not as robust and coordinated as it could be. The best error handling can be found in IAS and binding code, other parts like executing user commands mostly don\u2019t have any error handling at all and carry out commands in a fire and forget approach. Supporting new devices often requires adding device specific code and quirks in C++, which led to functions going way over a couple of hundrets lines of code, always with the danger of breaking already existing devices and introducing bugs. New Device code \u00b6 The Device code is designed to provide a solution to known issues in the classic REST-API code. Features and goals 100\u2009% testability for happy paths as well as all errors and faults which might happen. Well structured modular code with minimal dependencies betweend modules. The C++ part shall know as little as possible about specific devices. Device details are described in Device Description Files (DDF) in JSON format. Handling of all errors and faults which might occur. Only small functions with max. of 200 lines of code. Adding a new device can\u2019t break another. With a code base almost a decade old the Device code can\u2019t replace everything at once, therefore it runs in parallel to classic REST-API code and replaces parts of it incrementally.","title":"Introduction"},{"location":"#introduction","text":"Work in Progress This documentation describes the deCONZ C++ development around the newer so called Device code and Device Description Files (DDF). The discussion takes place in the deCONZ REST-API Plugin V2 repository on GitHub.","title":"Introduction"},{"location":"#classic-rest-api-code","text":"The classic REST-API code handles sensors and lights in command handlers which iterate over respective containers. In these loops the code parses commands, often specific to devices based on their model identifier and take further actions. The ability to recover from errors and faults is limited and often not as robust and coordinated as it could be. The best error handling can be found in IAS and binding code, other parts like executing user commands mostly don\u2019t have any error handling at all and carry out commands in a fire and forget approach. Supporting new devices often requires adding device specific code and quirks in C++, which led to functions going way over a couple of hundrets lines of code, always with the danger of breaking already existing devices and introducing bugs.","title":"Classic REST-API code"},{"location":"#new-device-code","text":"The Device code is designed to provide a solution to known issues in the classic REST-API code. Features and goals 100\u2009% testability for happy paths as well as all errors and faults which might happen. Well structured modular code with minimal dependencies betweend modules. The C++ part shall know as little as possible about specific devices. Device details are described in Device Description Files (DDF) in JSON format. Handling of all errors and faults which might occur. Only small functions with max. of 200 lines of code. Adding a new device can\u2019t break another. With a code base almost a decade old the Device code can\u2019t replace everything at once, therefore it runs in parallel to classic REST-API code and replaces parts of it incrementally.","title":"New Device code"},{"location":"modules/class-device/","text":"Device class \u00b6 Work in Progress The Device class manages a single physical device. It controls sub-devices like sensors and lights soley by using their Resource and ResourceItem interface. C++ sources: device.h and device.cpp Overview \u00b6 The difference to classic C++ plugin code is best described by an example. The next sections show how a Philips Hue Motion Sensor is handled by classic C++ code vs. the new Device code. Classic C++ code \u00b6 A Philips Hue Motion Sensor with model identifier \u201cSML001\u201d has three Sensor objects. Pairing: The sensors are created and configured by: addSensorNode(const deCONZ::Node *node, const deCONZ::NodeEvent *event); addSensorNode(const deCONZ::Node *node, const SensorFingerprint &fingerPrint, const QString &type, const QString &modelId, const QString &manufacturer); delayedFastEnddeviceProbe(const deCONZ::NodeEvent *event); checkSensorBindingsForAttributeReporting(Sensor *sensor); Operaration: Once configured, messages from the sensor are processed in: updateSensorNode(const deCONZ::NodeEvent &event); Problems The mentioned functions are huge, e.g. updateSensorNode() is over 1700 lines long Some parts of the code specifically handle \u201cSML00\u201d modelid There is little error handling and pairing might fail Device code \u00b6 The new code creates the same three sensors, but doesn\u2019t use any of the above functions. The first notable thing is a hierarchy: The Device object acts as a controller for the sensors (sub-devices). Note: That Sensor and LightNode classes inherit from the Resource class. This makes them accessible to the Device class. Pairing: Is done by the per device state machine which: Reads all ZDP descriptors Reads ZCL Basic Cluster modelid and manufacturer name Passes this data to the DDF Loader class (which creates the three sensors based on a DDF file) Configures all Bindings and ZCL attribute reporting which are defined in the DDF file Reads and writes ZCL attributes defined in the DDF file Remarks The described steps are the same for all devices The state machine handles all errors or faults quickly The involved C++ code knows nothing about a specific device, this is all described in the DDF file. The Device class isn\u2019t aware about sleeping end-devices or routers, the knowledge that a device is able to receive commands comes from Awake and Poll Events which are generated by external classes and command handlers. State Machine \u00b6 Each Device is driven by its own internal state machine. The states are implemented as a functions that act on events. The Device::handleEvent(Event) method passes the events to the current state, which is internally a function pointer to one of the following state functions: void DEV_InitStateHandler(Device *device, const Event &event); void DEV_IdleStateHandler(Device *device, const Event &event); void DEV_NodeDescriptorStateHandler(Device *device, const Event &event); void DEV_ActiveEndpointsStateHandler(Device *device, const Event &event); void DEV_SimpleDescriptorStateHandler(Device *device, const Event &event); void DEV_BasicClusterStateHandler(Device *device, const Event &event); void DEV_GetDeviceDescriptionHandler(Device *device, const Event &event); void DEV_BindingHandler(Device *device, const Event &event); void DEV_BindingTableVerifyHandler(Device *device, const Event &event); void DEV_PollIdleStateHandler(Device *device, const Event &event); void DEV_PollNextStateHandler(Device *device, const Event &event); void DEV_PollBusyStateHandler(Device *device, const Event &event); High Level View \u00b6 The following diagram shows the general flow of the state machine. Once the basic setup is done after the Get DDF state, the device enters the Operating/Idle State which runs multiple sub states in parallel. If an error happens the state machine jumps back to the Init State and retries naturally. Diagram source: device_bindings.puml Timing \u00b6 Other than internal timeouts the timing of the state machine is controlled by events send from the DeviceTick class (see device_tick.h ). Error handling \u00b6 The following diagram shows how error handling for ZDP Requests is done in the DEV_NodeDescriptorStateHandler() state function, the same principle applies for Active Endpoints and Simple Descriptors states. Diagram source: device_state_node_descriptor.puml Bindings \u00b6 ZDP binding and ZCL reporting configuration is maintained during the full life cycle of the device by the Binding sub state. If any error or fault happens the state machine recovers automatically and verifies the configuration. In contrast to classic REST-API C++ code the state machine also detects changes in reporting configuration and is able to apply those. Each device has it\u2019s own copy of binding and ZCL reporting configuration which allows us later to provide custom configuration on a per device base. Discussion in issues/6 The configuration for bindings and ZCL reporting is specified in DDF files, for example: ikea/gu10_ws_400lm_light.json . Diagram source: device_bindings.puml Sub-devices \u00b6 The Device class only queries ZDP descriptors and the ZCL Basic Cluster attributes modelid and manufacturer name. After that DDF files are used to create sub-devices like sensors and lights. Sub-devices are created by the DDF Loader , not the Device class itself. When the Get DDF state is entered the Device sends the REventDDFInitRequest event and waits. The DDF Loader sends a REventDDFInitResponse event, at that time all sub device Resources and ResourceItems are initialized and the Device class goes into Operational/Idle state. The Device Compat (compatibility) module creates empty Sensor and LightNode objects and adds them to the respective plugin sensors and nodes containers. The DDF Init module then fills the ResourceItems based on the DDF file and registers the Resource in the Device . This way the \u201cold\u201d code as well as the Device can work side by side, albeit the Device doesn\u2019t know anything about this. This process can be repeated at any time, for example during development of DDF files they can be reloaded on-the-fly without restarting deCONZ. Testing \u00b6 Beside loose coupling, the minimal dependencies allow easier testing of the class and its behaviour of the state machine. In general all Device code is kept small and has no functions longer than two screen pages (if it does it is a bug). The goal is to get close to 100% test coverage, since internally mostly free standing functions are used this becomes straight forward. Each state and sub states can be tested in isolation as well as complete sequences like device pairing. First steps to test the Device class behaviour can be found in 001-device-1.cpp . Dependencies \u00b6 The class depends only on a few other classes and modules. Resource as base class and to access sub devices Event to interact with other components and provide lose coupling deCONZ::Node to access ZDP Simple Descriptors and Node Descriptor Device Access (DA) module to execute abstract named C++ parse, read and write functions (Examples: IKEA KADRILJ DDF and state/on item ) ZDP module to query ZDP descriptors during setup; ZCL module to query ZCL Basic Cluster attributes during setup. Note There are no dependencies to DeRestPlugin , RestNodeBase , Sensor or LightNode classes, even deCONZ::ApsController is just an opaque pointer. All the class sees, is a device which has sub-devices as Resource and their ResourceItems .","title":"Device class"},{"location":"modules/class-device/#device-class","text":"Work in Progress The Device class manages a single physical device. It controls sub-devices like sensors and lights soley by using their Resource and ResourceItem interface. C++ sources: device.h and device.cpp","title":"Device class"},{"location":"modules/class-device/#overview","text":"The difference to classic C++ plugin code is best described by an example. The next sections show how a Philips Hue Motion Sensor is handled by classic C++ code vs. the new Device code.","title":"Overview"},{"location":"modules/class-device/#classic-c-code","text":"A Philips Hue Motion Sensor with model identifier \u201cSML001\u201d has three Sensor objects. Pairing: The sensors are created and configured by: addSensorNode(const deCONZ::Node *node, const deCONZ::NodeEvent *event); addSensorNode(const deCONZ::Node *node, const SensorFingerprint &fingerPrint, const QString &type, const QString &modelId, const QString &manufacturer); delayedFastEnddeviceProbe(const deCONZ::NodeEvent *event); checkSensorBindingsForAttributeReporting(Sensor *sensor); Operaration: Once configured, messages from the sensor are processed in: updateSensorNode(const deCONZ::NodeEvent &event); Problems The mentioned functions are huge, e.g. updateSensorNode() is over 1700 lines long Some parts of the code specifically handle \u201cSML00\u201d modelid There is little error handling and pairing might fail","title":"Classic C++ code"},{"location":"modules/class-device/#device-code","text":"The new code creates the same three sensors, but doesn\u2019t use any of the above functions. The first notable thing is a hierarchy: The Device object acts as a controller for the sensors (sub-devices). Note: That Sensor and LightNode classes inherit from the Resource class. This makes them accessible to the Device class. Pairing: Is done by the per device state machine which: Reads all ZDP descriptors Reads ZCL Basic Cluster modelid and manufacturer name Passes this data to the DDF Loader class (which creates the three sensors based on a DDF file) Configures all Bindings and ZCL attribute reporting which are defined in the DDF file Reads and writes ZCL attributes defined in the DDF file Remarks The described steps are the same for all devices The state machine handles all errors or faults quickly The involved C++ code knows nothing about a specific device, this is all described in the DDF file. The Device class isn\u2019t aware about sleeping end-devices or routers, the knowledge that a device is able to receive commands comes from Awake and Poll Events which are generated by external classes and command handlers.","title":"Device code"},{"location":"modules/class-device/#state-machine","text":"Each Device is driven by its own internal state machine. The states are implemented as a functions that act on events. The Device::handleEvent(Event) method passes the events to the current state, which is internally a function pointer to one of the following state functions: void DEV_InitStateHandler(Device *device, const Event &event); void DEV_IdleStateHandler(Device *device, const Event &event); void DEV_NodeDescriptorStateHandler(Device *device, const Event &event); void DEV_ActiveEndpointsStateHandler(Device *device, const Event &event); void DEV_SimpleDescriptorStateHandler(Device *device, const Event &event); void DEV_BasicClusterStateHandler(Device *device, const Event &event); void DEV_GetDeviceDescriptionHandler(Device *device, const Event &event); void DEV_BindingHandler(Device *device, const Event &event); void DEV_BindingTableVerifyHandler(Device *device, const Event &event); void DEV_PollIdleStateHandler(Device *device, const Event &event); void DEV_PollNextStateHandler(Device *device, const Event &event); void DEV_PollBusyStateHandler(Device *device, const Event &event);","title":"State Machine"},{"location":"modules/class-device/#high-level-view","text":"The following diagram shows the general flow of the state machine. Once the basic setup is done after the Get DDF state, the device enters the Operating/Idle State which runs multiple sub states in parallel. If an error happens the state machine jumps back to the Init State and retries naturally. Diagram source: device_bindings.puml","title":"High Level View"},{"location":"modules/class-device/#timing","text":"Other than internal timeouts the timing of the state machine is controlled by events send from the DeviceTick class (see device_tick.h ).","title":"Timing"},{"location":"modules/class-device/#error-handling","text":"The following diagram shows how error handling for ZDP Requests is done in the DEV_NodeDescriptorStateHandler() state function, the same principle applies for Active Endpoints and Simple Descriptors states. Diagram source: device_state_node_descriptor.puml","title":"Error handling"},{"location":"modules/class-device/#bindings","text":"ZDP binding and ZCL reporting configuration is maintained during the full life cycle of the device by the Binding sub state. If any error or fault happens the state machine recovers automatically and verifies the configuration. In contrast to classic REST-API C++ code the state machine also detects changes in reporting configuration and is able to apply those. Each device has it\u2019s own copy of binding and ZCL reporting configuration which allows us later to provide custom configuration on a per device base. Discussion in issues/6 The configuration for bindings and ZCL reporting is specified in DDF files, for example: ikea/gu10_ws_400lm_light.json . Diagram source: device_bindings.puml","title":"Bindings"},{"location":"modules/class-device/#sub-devices","text":"The Device class only queries ZDP descriptors and the ZCL Basic Cluster attributes modelid and manufacturer name. After that DDF files are used to create sub-devices like sensors and lights. Sub-devices are created by the DDF Loader , not the Device class itself. When the Get DDF state is entered the Device sends the REventDDFInitRequest event and waits. The DDF Loader sends a REventDDFInitResponse event, at that time all sub device Resources and ResourceItems are initialized and the Device class goes into Operational/Idle state. The Device Compat (compatibility) module creates empty Sensor and LightNode objects and adds them to the respective plugin sensors and nodes containers. The DDF Init module then fills the ResourceItems based on the DDF file and registers the Resource in the Device . This way the \u201cold\u201d code as well as the Device can work side by side, albeit the Device doesn\u2019t know anything about this. This process can be repeated at any time, for example during development of DDF files they can be reloaded on-the-fly without restarting deCONZ.","title":"Sub-devices"},{"location":"modules/class-device/#testing","text":"Beside loose coupling, the minimal dependencies allow easier testing of the class and its behaviour of the state machine. In general all Device code is kept small and has no functions longer than two screen pages (if it does it is a bug). The goal is to get close to 100% test coverage, since internally mostly free standing functions are used this becomes straight forward. Each state and sub states can be tested in isolation as well as complete sequences like device pairing. First steps to test the Device class behaviour can be found in 001-device-1.cpp .","title":"Testing"},{"location":"modules/class-device/#dependencies","text":"The class depends only on a few other classes and modules. Resource as base class and to access sub devices Event to interact with other components and provide lose coupling deCONZ::Node to access ZDP Simple Descriptors and Node Descriptor Device Access (DA) module to execute abstract named C++ parse, read and write functions (Examples: IKEA KADRILJ DDF and state/on item ) ZDP module to query ZDP descriptors during setup; ZCL module to query ZCL Basic Cluster attributes during setup. Note There are no dependencies to DeRestPlugin , RestNodeBase , Sensor or LightNode classes, even deCONZ::ApsController is just an opaque pointer. All the class sees, is a device which has sub-devices as Resource and their ResourceItems .","title":"Dependencies"},{"location":"modules/ddf/","text":"Device Description Files \u00b6 This is a draft document to explore Device Description Files (DDF). Work in Progress Goals \u00b6 Describe devices and their capabilities in JSON files. Simplify contribution of new device handlers without C++ knowledge. Cleanup many of the C++ device specific quirks to simplify the code base. Smooth transition: DDF files won\u2019t replace existing implementations in one big release, but rather will be used for a device when available. Automated generation of device documentation and supported devices lists. Handling in other projects \u00b6 SmartThings Device handlers are implemented in .groovy files which may contain one or more device descriptions, e.g. xiaomi-aqara-button.groovy . Zigbee2MQTT Used one large devices.js file in the past. New code uses modular device specific converters, one per manufacturer, written in Javascript, e.g. xiaomi.js . Similar devices inherit common functions from base files. https://www.zigbee2mqtt.io/how_tos/how_to_support_new_devices.html Home Assistant ZHA Device handlers are maintained in the zigpy project written in Python. https://github.com/zigpy/zha-device-handlers Directory structure \u00b6 Since the amount of devices is expected to grow quickly, over time there will be hundreds of device descriptions. In order to be maintainable they need to be organized with the aim to prevent \u201cmonster\u201d files. The current implementation uses one directory per vendor and one file per product: devices/ generic/ items/ ikea/ motion-sensor.json button5-remote1.json button5-remote2.json e27_cws_opal_600lm_light.json gu10_ws_400lm_light.json kadrilj_blind.json philips/ sml001_motion_sensor.json dimmer_switch.json sunricher/ dimmer.json This is similar to SmartThings device descriptions. The REST-API plugin loads DDF files by traversing through the directory tree, and for easier development can even hot reload them when a file changes. DDF file content \u00b6 A DDF file provides a high level view and contains references to where data is located as well as the commands which can be called. In contrast to other projects most of the implementation details are not exposed. Example IKEA TR\u00c5DFRI bulb GU10 WS 400lm { \"schema\": \"devcap1.schema.json\", \"doc:path\": \"ikea/gu10_ws_400lm_light.md\", \"doc:hdr\": \"TR\u00c5DFRI bulb GU10 WS 400lm\", \"manufacturername\": \"$MF_IKEA\", \"modelid\": \"TRADFRI bulb GU10 WS 400lm\", \"product\": \"TR\u00c5DFRI bulb GU10 WS 400lm\", \"status\": \"Bronze\", \"md:known_issues\": [ \"ikea_known_issues_radio_silence.md\" ], \"supportsMgmtBind\": true, \"subdevices\": [ { \"type\": \"$TYPE_COLOR_TEMPERATURE_LIGHT\", \"restapi\": \"/lights\", \"uuid\": [\"$address.ext\", \"0x01\"], \"items\": [ { \"name\": \"attr/lastannounced\" }, { \"name\": \"attr/lastseen\" }, { \"name\": \"attr/manufacturername\" }, { \"name\": \"attr/modelid\" }, { \"name\": \"attr/name\" }, { \"name\": \"attr/swversion\" }, { \"name\": \"attr/type\" }, { \"name\": \"attr/uniqueid\" }, { \"name\": \"config/colorcapabilities\", \"default\": 16 }, { \"name\": \"config/ctmin\", \"default\": 250 }, { \"name\": \"config/ctmax\", \"default\": 454 }, { \"name\": \"state/on\" }, { \"name\": \"state/bri\"}, { \"name\": \"state/ct\" }, { \"name\": \"state/reachable\" }, { \"name\": \"state/colormode\" }, { \"name\": \"state/alert\" } ] } ], \"bindings\": [ { \"bind\": \"unicast\", \"src.ep\": 1, \"cl\": \"0x0006\", \"report\": [ {\"at\": \"0x0000\", \"dt\": \"0x10\", \"min\": 5, \"max\": 1800 } ] }, { \"bind\": \"unicast\", \"src.ep\": 1, \"cl\": \"0x0008\", \"report\": [ {\"at\": \"0x0000\", \"dt\": \"0x20\", \"min\": 5, \"max\": 1800, \"change\": \"0x01\" } ] }, { \"bind\": \"unicast\", \"src.ep\": 1, \"cl\": \"0x0300\", \"report\": [ {\"at\": \"0x0008\", \"dt\": \"0x30\", \"min\": 1, \"max\": 1800 }, {\"at\": \"0x0003\", \"dt\": \"0x21\", \"min\": 5, \"max\": 1795, \"change\": \"0x0a\" }, {\"at\": \"0x0004\", \"dt\": \"0x21\", \"min\": 5, \"max\": 1795, \"change\": \"0x0a\" }, {\"at\": \"0x0007\", \"dt\": \"0x21\", \"min\": 5, \"max\": 1800, \"change\": \"0x01\" } ] } ] } This DDF file describes the light with one sub-resource. The schema key references the JSON schema against which the device can be verified. String values which are prefixed with $ , like \"$MF_IKEA\" are constants and will be replaced with the actual values in the plugin. These keys might be defined in another JSON file or come from the ZCLDB. The uuid field specifies the parts of which the uniqueId will be generated. The subdevices array may hold one or more sub devices like lights and sensors. The items array contains items where the name refers to a ResourceItem suffix. These items are merged with the content of generic/items/<name>.json . The bindings array contains all bindings and respective reporting configuration. Generic items \u00b6 Each item may have read, write and parse functions to build the bridge between Zigbee and the ResourceItem . The generic items provide defaults for these functions, for example generic/items/config_checkin_item.json is written as: { \"schema\": \"resourceitem1.schema.json\", \"id\": \"config/checkin\", \"datatype\": \"UInt32\", \"access\": \"RW\", \"public\": false, \"range\": [0, 4294967295], \"description\": \"Configures the check-in interval for the Poll Control cluster.\", \"parse\": {\"fn\": \"zcl\", \"ep\": 0, \"cl\": \"0x0020\", \"at\": \"0x0000\", \"eval\": \"Item.val = Attr.val\"}, \"read\": {\"fn\": \"zcl\", \"ep\": 0, \"cl\": \"0x0020\", \"at\": \"0x0000\"}, \"write\": {\"fn\": \"zcl\", \"ep\": 0, \"cl\": \"0x0020\", \"at\": \"0x0000\", \"dt\": \"0x23\", \"eval\": \"Item.val\"}, \"refresh.interval\": 3600 } If a DDF file contains the item {\"name\": \"config/checkin\"} the above content will be loaded. Every key can be overwritten in the DDF file if device specific customizations are needed. Parsing Zigbee messages \u00b6 The parse key references a named C++ function which can be specified to parse and transform an incoming APSDE-DATA.indication and derive the ResourceItem value from it. Often the generic parse function is sufficient for example the item state/bri is parameterized as: { \"name\": \"state/bri\", \"parse\": { \"fn\": \"zcl\", \"ep\": 1, \"cl\": \"0x0008\", \"at\": \"0x0000\", \"eval\": \"Item.val = Attr.val * 254 / 100\" } } which means: Use the named C++ parse function \"zcl\" ; (Note the \"fn\": \"zcl\" key is optional since it\u2019s the default if ommited) When a ZCL Read Attributes Response or ZCL Attribute Report command is received on endpoint 1, cluster 0x0008, containing the attribute 0x0000; Parse the value and evaluate the expression Item.val = Attr.val * 254 / 100 where Item and Attr are the ResourceItem and deCONZ::ZclAttribute exposed to the Javascript engine. The result will be the new value of the ResourceItem and related events are fired automatically. Note: Javascript expressions are evaluated via QJSEngine . The function pointer \u201cfn\u201d \u00b6 The \"fn\" key is like a function pointer in C++ which points to a specific read, write or parse function. The default {\"parse\": { \"fn\": \"zcl\", ... }} function can be applied in many cases but specialized functions for other cases like {\"parse\": { \"fn\": \"xiaomi:special\", ... }} can be implemented to simplify certain tasks. The remaining key-value pairs in the \"parse\" object are interpretet within the specific parse function. Note that alternative functions can use different parameters and some parameters like \"mfcode\" are optional and have default values. Evaluating Javascript \u00b6 The \"eval\" key in the \"zcl\" functions is the most basic yet powerful approach to support reading writing and parsing of arbitrary Zigbee messages without having to implement any C++ code for yet another custom Zigbee device. Without Javascript \u00b6 Since read, write and parse functions are just abstract function pointers it\u2019s always possible to implement a tailored named C++ function which can be referenced via the \"fn\" key, for example common functions like {\"fn\": \"parse.zcl.battery\"} can be added which don\u2019t use Javascript at all. The C++ code for currently implemended functions can be found in device_access_fn.cpp . Commands \u00b6 Not Implemented yet Commands reference C++ functions which will be called via the REST-API. Similar to parsing ZCL values they can transform the values coming from the REST-API into values which fit the specific device, for example in order to reverse the lift value. For some devices the standard functions don\u2019t fit and alternate commands can be specified to carry out the same task. For example the Xiaomi curtain motor uses non standard interface to change the state/lift value, here a {\"cmd\": \"lift\", \"fn\": \"xiaomiWindowCoveringLift\", \"ep\": 1, \"cl\": \"0x0102\", \"at\": \"0x0008\", \"eval\": \"100 - Item.val\"} could be specified. For convenience simpler functions can be provided, for example the standard window covering lift function can be specified as: {\"cmd\": \"lift\", \"fn\": \"windowCoveringLift\", \"eval\": \"Item.val\"} since often the {Endpoint, ClusterId, AttributeId} parameters can figured out automatically. In the example above the windowCoveringStop is such a case. The goal should be to figure out functions which need as little parameters as possible to keep the device description files as simple as possible. Button maps \u00b6 For switches state/buttonevent refers to device specific clusters and attributes. The JSON button maps https://github.com/dresden-elektronik/deconz-rest-plugin/pull/3127 describe the transformations from Zigbee \u2192 state/buttonevent . These button maps could be part of the device capabilities file itself to keep everything together. Validation \u00b6 Each device description can be validated against a JSON schema to prevent errors. Like it\u2019s already done for Button Maps the verification can be automated via GitHub actions for pull request. The JSON schema further provides a way to specify versions of supported schemas. Example DDF files \u00b6 The following examples demonstrate notable features in already working DDF files. Note these DDF files deliberately use Javascript eval capabilities to show what is possible without writing C++ code. The auto generated documentation can be found at: https://dresden-elektronik.github.io/deconz-rest-doc/devices IKEA KADRILJ roller blind \u00b6 Source: devices/ikea/kadrilj_blind.json Two sub-resources under /lights and /sensors Customized parse function parameters Some items marked as deprecated Binding and reporting configuration Philips Hue motion sensor \u00b6 Source: devices/philips/sml001_motion_sensor.json Three /sensors sub-resources Manufacturer specific ZCL attribute parsing External Javascript to parse state/lightlevel Binding and reporting configuration Philips Hue dimmer switch \u00b6 Source: devices/philips/rwl02_dimmer_switch.json One /sensors sub-resource Manufacturer specific ZCL attribute reading, writing and parsing Binding and reporting configuration Xiaomi vibration sensor DJT11LM \u00b6 Source: devices/xiaomi/aq1_vibration_sensor.json One /sensors sub-resource Manufacturer specific ZCL attribute reading, writing and parsing Customized attr/swversion parsing Using custom {\"fn\":\"xiaomi:special\"} parse function External Javascript to parse config/battery which can be shared with other Xiaomi DDF files External Javascript to parse state/orientation","title":"Device Description Files"},{"location":"modules/ddf/#device-description-files","text":"This is a draft document to explore Device Description Files (DDF). Work in Progress","title":"Device Description Files"},{"location":"modules/ddf/#goals","text":"Describe devices and their capabilities in JSON files. Simplify contribution of new device handlers without C++ knowledge. Cleanup many of the C++ device specific quirks to simplify the code base. Smooth transition: DDF files won\u2019t replace existing implementations in one big release, but rather will be used for a device when available. Automated generation of device documentation and supported devices lists.","title":"Goals"},{"location":"modules/ddf/#handling-in-other-projects","text":"SmartThings Device handlers are implemented in .groovy files which may contain one or more device descriptions, e.g. xiaomi-aqara-button.groovy . Zigbee2MQTT Used one large devices.js file in the past. New code uses modular device specific converters, one per manufacturer, written in Javascript, e.g. xiaomi.js . Similar devices inherit common functions from base files. https://www.zigbee2mqtt.io/how_tos/how_to_support_new_devices.html Home Assistant ZHA Device handlers are maintained in the zigpy project written in Python. https://github.com/zigpy/zha-device-handlers","title":"Handling in other projects"},{"location":"modules/ddf/#directory-structure","text":"Since the amount of devices is expected to grow quickly, over time there will be hundreds of device descriptions. In order to be maintainable they need to be organized with the aim to prevent \u201cmonster\u201d files. The current implementation uses one directory per vendor and one file per product: devices/ generic/ items/ ikea/ motion-sensor.json button5-remote1.json button5-remote2.json e27_cws_opal_600lm_light.json gu10_ws_400lm_light.json kadrilj_blind.json philips/ sml001_motion_sensor.json dimmer_switch.json sunricher/ dimmer.json This is similar to SmartThings device descriptions. The REST-API plugin loads DDF files by traversing through the directory tree, and for easier development can even hot reload them when a file changes.","title":"Directory structure"},{"location":"modules/ddf/#ddf-file-content","text":"A DDF file provides a high level view and contains references to where data is located as well as the commands which can be called. In contrast to other projects most of the implementation details are not exposed. Example IKEA TR\u00c5DFRI bulb GU10 WS 400lm { \"schema\": \"devcap1.schema.json\", \"doc:path\": \"ikea/gu10_ws_400lm_light.md\", \"doc:hdr\": \"TR\u00c5DFRI bulb GU10 WS 400lm\", \"manufacturername\": \"$MF_IKEA\", \"modelid\": \"TRADFRI bulb GU10 WS 400lm\", \"product\": \"TR\u00c5DFRI bulb GU10 WS 400lm\", \"status\": \"Bronze\", \"md:known_issues\": [ \"ikea_known_issues_radio_silence.md\" ], \"supportsMgmtBind\": true, \"subdevices\": [ { \"type\": \"$TYPE_COLOR_TEMPERATURE_LIGHT\", \"restapi\": \"/lights\", \"uuid\": [\"$address.ext\", \"0x01\"], \"items\": [ { \"name\": \"attr/lastannounced\" }, { \"name\": \"attr/lastseen\" }, { \"name\": \"attr/manufacturername\" }, { \"name\": \"attr/modelid\" }, { \"name\": \"attr/name\" }, { \"name\": \"attr/swversion\" }, { \"name\": \"attr/type\" }, { \"name\": \"attr/uniqueid\" }, { \"name\": \"config/colorcapabilities\", \"default\": 16 }, { \"name\": \"config/ctmin\", \"default\": 250 }, { \"name\": \"config/ctmax\", \"default\": 454 }, { \"name\": \"state/on\" }, { \"name\": \"state/bri\"}, { \"name\": \"state/ct\" }, { \"name\": \"state/reachable\" }, { \"name\": \"state/colormode\" }, { \"name\": \"state/alert\" } ] } ], \"bindings\": [ { \"bind\": \"unicast\", \"src.ep\": 1, \"cl\": \"0x0006\", \"report\": [ {\"at\": \"0x0000\", \"dt\": \"0x10\", \"min\": 5, \"max\": 1800 } ] }, { \"bind\": \"unicast\", \"src.ep\": 1, \"cl\": \"0x0008\", \"report\": [ {\"at\": \"0x0000\", \"dt\": \"0x20\", \"min\": 5, \"max\": 1800, \"change\": \"0x01\" } ] }, { \"bind\": \"unicast\", \"src.ep\": 1, \"cl\": \"0x0300\", \"report\": [ {\"at\": \"0x0008\", \"dt\": \"0x30\", \"min\": 1, \"max\": 1800 }, {\"at\": \"0x0003\", \"dt\": \"0x21\", \"min\": 5, \"max\": 1795, \"change\": \"0x0a\" }, {\"at\": \"0x0004\", \"dt\": \"0x21\", \"min\": 5, \"max\": 1795, \"change\": \"0x0a\" }, {\"at\": \"0x0007\", \"dt\": \"0x21\", \"min\": 5, \"max\": 1800, \"change\": \"0x01\" } ] } ] } This DDF file describes the light with one sub-resource. The schema key references the JSON schema against which the device can be verified. String values which are prefixed with $ , like \"$MF_IKEA\" are constants and will be replaced with the actual values in the plugin. These keys might be defined in another JSON file or come from the ZCLDB. The uuid field specifies the parts of which the uniqueId will be generated. The subdevices array may hold one or more sub devices like lights and sensors. The items array contains items where the name refers to a ResourceItem suffix. These items are merged with the content of generic/items/<name>.json . The bindings array contains all bindings and respective reporting configuration.","title":"DDF file content"},{"location":"modules/ddf/#generic-items","text":"Each item may have read, write and parse functions to build the bridge between Zigbee and the ResourceItem . The generic items provide defaults for these functions, for example generic/items/config_checkin_item.json is written as: { \"schema\": \"resourceitem1.schema.json\", \"id\": \"config/checkin\", \"datatype\": \"UInt32\", \"access\": \"RW\", \"public\": false, \"range\": [0, 4294967295], \"description\": \"Configures the check-in interval for the Poll Control cluster.\", \"parse\": {\"fn\": \"zcl\", \"ep\": 0, \"cl\": \"0x0020\", \"at\": \"0x0000\", \"eval\": \"Item.val = Attr.val\"}, \"read\": {\"fn\": \"zcl\", \"ep\": 0, \"cl\": \"0x0020\", \"at\": \"0x0000\"}, \"write\": {\"fn\": \"zcl\", \"ep\": 0, \"cl\": \"0x0020\", \"at\": \"0x0000\", \"dt\": \"0x23\", \"eval\": \"Item.val\"}, \"refresh.interval\": 3600 } If a DDF file contains the item {\"name\": \"config/checkin\"} the above content will be loaded. Every key can be overwritten in the DDF file if device specific customizations are needed.","title":"Generic items"},{"location":"modules/ddf/#parsing-zigbee-messages","text":"The parse key references a named C++ function which can be specified to parse and transform an incoming APSDE-DATA.indication and derive the ResourceItem value from it. Often the generic parse function is sufficient for example the item state/bri is parameterized as: { \"name\": \"state/bri\", \"parse\": { \"fn\": \"zcl\", \"ep\": 1, \"cl\": \"0x0008\", \"at\": \"0x0000\", \"eval\": \"Item.val = Attr.val * 254 / 100\" } } which means: Use the named C++ parse function \"zcl\" ; (Note the \"fn\": \"zcl\" key is optional since it\u2019s the default if ommited) When a ZCL Read Attributes Response or ZCL Attribute Report command is received on endpoint 1, cluster 0x0008, containing the attribute 0x0000; Parse the value and evaluate the expression Item.val = Attr.val * 254 / 100 where Item and Attr are the ResourceItem and deCONZ::ZclAttribute exposed to the Javascript engine. The result will be the new value of the ResourceItem and related events are fired automatically. Note: Javascript expressions are evaluated via QJSEngine .","title":"Parsing Zigbee messages"},{"location":"modules/ddf/#the-function-pointer-fn","text":"The \"fn\" key is like a function pointer in C++ which points to a specific read, write or parse function. The default {\"parse\": { \"fn\": \"zcl\", ... }} function can be applied in many cases but specialized functions for other cases like {\"parse\": { \"fn\": \"xiaomi:special\", ... }} can be implemented to simplify certain tasks. The remaining key-value pairs in the \"parse\" object are interpretet within the specific parse function. Note that alternative functions can use different parameters and some parameters like \"mfcode\" are optional and have default values.","title":"The function pointer \"fn\""},{"location":"modules/ddf/#evaluating-javascript","text":"The \"eval\" key in the \"zcl\" functions is the most basic yet powerful approach to support reading writing and parsing of arbitrary Zigbee messages without having to implement any C++ code for yet another custom Zigbee device.","title":"Evaluating Javascript"},{"location":"modules/ddf/#without-javascript","text":"Since read, write and parse functions are just abstract function pointers it\u2019s always possible to implement a tailored named C++ function which can be referenced via the \"fn\" key, for example common functions like {\"fn\": \"parse.zcl.battery\"} can be added which don\u2019t use Javascript at all. The C++ code for currently implemended functions can be found in device_access_fn.cpp .","title":"Without Javascript"},{"location":"modules/ddf/#commands","text":"Not Implemented yet Commands reference C++ functions which will be called via the REST-API. Similar to parsing ZCL values they can transform the values coming from the REST-API into values which fit the specific device, for example in order to reverse the lift value. For some devices the standard functions don\u2019t fit and alternate commands can be specified to carry out the same task. For example the Xiaomi curtain motor uses non standard interface to change the state/lift value, here a {\"cmd\": \"lift\", \"fn\": \"xiaomiWindowCoveringLift\", \"ep\": 1, \"cl\": \"0x0102\", \"at\": \"0x0008\", \"eval\": \"100 - Item.val\"} could be specified. For convenience simpler functions can be provided, for example the standard window covering lift function can be specified as: {\"cmd\": \"lift\", \"fn\": \"windowCoveringLift\", \"eval\": \"Item.val\"} since often the {Endpoint, ClusterId, AttributeId} parameters can figured out automatically. In the example above the windowCoveringStop is such a case. The goal should be to figure out functions which need as little parameters as possible to keep the device description files as simple as possible.","title":"Commands"},{"location":"modules/ddf/#button-maps","text":"For switches state/buttonevent refers to device specific clusters and attributes. The JSON button maps https://github.com/dresden-elektronik/deconz-rest-plugin/pull/3127 describe the transformations from Zigbee \u2192 state/buttonevent . These button maps could be part of the device capabilities file itself to keep everything together.","title":"Button maps"},{"location":"modules/ddf/#validation","text":"Each device description can be validated against a JSON schema to prevent errors. Like it\u2019s already done for Button Maps the verification can be automated via GitHub actions for pull request. The JSON schema further provides a way to specify versions of supported schemas.","title":"Validation"},{"location":"modules/ddf/#example-ddf-files","text":"The following examples demonstrate notable features in already working DDF files. Note these DDF files deliberately use Javascript eval capabilities to show what is possible without writing C++ code. The auto generated documentation can be found at: https://dresden-elektronik.github.io/deconz-rest-doc/devices","title":"Example DDF files"},{"location":"modules/ddf/#ikea-kadrilj-roller-blind","text":"Source: devices/ikea/kadrilj_blind.json Two sub-resources under /lights and /sensors Customized parse function parameters Some items marked as deprecated Binding and reporting configuration","title":"IKEA KADRILJ roller blind"},{"location":"modules/ddf/#philips-hue-motion-sensor","text":"Source: devices/philips/sml001_motion_sensor.json Three /sensors sub-resources Manufacturer specific ZCL attribute parsing External Javascript to parse state/lightlevel Binding and reporting configuration","title":"Philips Hue motion sensor"},{"location":"modules/ddf/#philips-hue-dimmer-switch","text":"Source: devices/philips/rwl02_dimmer_switch.json One /sensors sub-resource Manufacturer specific ZCL attribute reading, writing and parsing Binding and reporting configuration","title":"Philips Hue dimmer switch"},{"location":"modules/ddf/#xiaomi-vibration-sensor-djt11lm","text":"Source: devices/xiaomi/aq1_vibration_sensor.json One /sensors sub-resource Manufacturer specific ZCL attribute reading, writing and parsing Customized attr/swversion parsing Using custom {\"fn\":\"xiaomi:special\"} parse function External Javascript to parse config/battery which can be shared with other Xiaomi DDF files External Javascript to parse state/orientation","title":"Xiaomi vibration sensor DJT11LM"},{"location":"modules/ddf-loader/","text":"DDF Loader \u00b6 Work in Progress device_descriptions.h device_descriptions.cpp","title":"DDF Loader"},{"location":"modules/ddf-loader/#ddf-loader","text":"Work in Progress device_descriptions.h device_descriptions.cpp","title":"DDF Loader"},{"location":"modules/fault-tolerance/","text":"Fault Tolerance \u00b6 Currently the inner handling of commands and state changes is not always robust, calls from the REST-API can fail to be carried out to devices. Zigbee commands may fail for various reasons, like: End-devices are sleeping Routing issues Send queue is full Network overloaded with group- or broadcasts Target devices aren\u2019t powered There are parts in the current code which deal with such issues, for example bindings and reporting configurations are mostly verified continuously. Tasks that might fail \u00b6 Groupcasts \u00b6 Sending a new state to a light group is currently implemented as a \u201cfire and forget\u201d groupcast command. It has been reported multiple times that this fails partly for IKEA lights, where some lights won\u2019t react albeit the command was sent. Likely because the device local BTT table is full and the command is silently discarded. Unicasts \u00b6 Same applies for here, for example light states are sent, but we don\u2019t verify the are actually applied. Further REST-API clients need to throttle how often they send a request. Setting the state for 50 lights ain\u2019t work because the send queue won\u2019t allow it. Configure a sleeping device \u00b6 Sending a configuration, e.g. to a sensor, can only be done if the sensor is awake. The same is true for thermostats and blinds which albeit being light sleepers may miss the command. Scenes \u00b6 The Zigbee scenes cluster is of rather mixed quality across vendors. The REST-API already knows what light states a certain scene should have, it is stored in the database. But it happens that just calling a scene doesn\u2019t restore it correctly in the device, for example my IKEA GU10 lights decided to mess up scenes after an OTA firmware update (I couldn\u2019t repair the scenes either). Handling of color temperature is another hopeless task. Device setup \u00b6 Some devices need to be configured after joining by writing attributes or sending certain commands. This works kind of ok but isn\u2019t robust. Ideas \u00b6 The biggest problem is the \u201cfire and forget\u201d approach. In the case that not all lights in a group react on the press of a remote control button it\u2019s really annoying for the user, pressing a button twice is a workaround but ugly. For fully automated systems this becomes an even larger issue, for example when thermostats are not controlled properly based on schedules or rules, or when light states aren\u2019t set based on schedules (football fields, malls, museums). More and more people having networks with over 100 nodes, here the problems increase. Things we know \u00b6 The state a device should have; When sleeping devices wake up event/awake ; The state a device actually has, by reading or reporting ZCL attributes; From a very simplified point of view all we need to do is to remember the state a device should have, verify the actual state and carry out respective commands in case the state isn\u2019t the desired one \u2014 piece of cake \u2014 \u2026 not really but we can get there. Possible generic approach \u00b6 In my device description experiments I\u2019ve added a small helper class StateChange which holds one little state machine per logical change. A logical change is something like set on/off, set brightness with transition time, write a ZCL value. High level view: * Multiple StateChange objects can be added to any Resource * The Device class pokes the state machine based on events (rx, polling, timeouts etc.) * A StateChange doesn\u2019t know anything about lights or sensors * It holds only references to ResourceItems which relate to ZCL values * It holds a function pointer to carry out a certain command * It may have an arbitrary long timeout to try to push the change * It is removed from the Resource as soon as the change is finished (verified) or the timeout hits A working very early implementation can be found at: https://github.com/manup/deconz-rest-plugin/commit/08cc3188693757a87008be93c9f2bca80628be60 This commit implements a robust (but lazy) verification of the on/off state of a light resource. Excerpt from PUT /lights/<id>/state const quint8 cmd = taskRef.onTime > 0 ? ONOFF_COMMAND_ON_WITH_TIMED_OFF : ONOFF_COMMAND_ON; ok = addTaskSetOnOff(task, cmd, taskRef.onTime, 0); StateChange change(StateChange::StateWaitSync, SC_SetOnOff, task.req.dstEndpoint()); change.addTargetValue(RStateOn, 0x01); change.addParameter(QLatin1String(\"cmd\"), cmd); if (cmd == ONOFF_COMMAND_ON_WITH_TIMED_OFF) { change.addParameter(QLatin1String(\"ontime\"), taskRef.onTime); } taskRef.lightNode->addStateChange(change); // addStateChange() is inherited from Resource* The SC_SetOnOff is a function pointer which will be called if the state can\u2019t be verified or on timeout. The addTaskSetOnOff() isn\u2019t even needed anymore, but I kept it here to demonstrate that these two can coexist. In future the StateChange or a similar approach is supposed to completely replace the Task based system in order to provide fault tolerance.","title":"Fault Tolerance"},{"location":"modules/fault-tolerance/#fault-tolerance","text":"Currently the inner handling of commands and state changes is not always robust, calls from the REST-API can fail to be carried out to devices. Zigbee commands may fail for various reasons, like: End-devices are sleeping Routing issues Send queue is full Network overloaded with group- or broadcasts Target devices aren\u2019t powered There are parts in the current code which deal with such issues, for example bindings and reporting configurations are mostly verified continuously.","title":"Fault Tolerance"},{"location":"modules/fault-tolerance/#tasks-that-might-fail","text":"","title":"Tasks that might fail"},{"location":"modules/fault-tolerance/#groupcasts","text":"Sending a new state to a light group is currently implemented as a \u201cfire and forget\u201d groupcast command. It has been reported multiple times that this fails partly for IKEA lights, where some lights won\u2019t react albeit the command was sent. Likely because the device local BTT table is full and the command is silently discarded.","title":"Groupcasts"},{"location":"modules/fault-tolerance/#unicasts","text":"Same applies for here, for example light states are sent, but we don\u2019t verify the are actually applied. Further REST-API clients need to throttle how often they send a request. Setting the state for 50 lights ain\u2019t work because the send queue won\u2019t allow it.","title":"Unicasts"},{"location":"modules/fault-tolerance/#configure-a-sleeping-device","text":"Sending a configuration, e.g. to a sensor, can only be done if the sensor is awake. The same is true for thermostats and blinds which albeit being light sleepers may miss the command.","title":"Configure a sleeping device"},{"location":"modules/fault-tolerance/#scenes","text":"The Zigbee scenes cluster is of rather mixed quality across vendors. The REST-API already knows what light states a certain scene should have, it is stored in the database. But it happens that just calling a scene doesn\u2019t restore it correctly in the device, for example my IKEA GU10 lights decided to mess up scenes after an OTA firmware update (I couldn\u2019t repair the scenes either). Handling of color temperature is another hopeless task.","title":"Scenes"},{"location":"modules/fault-tolerance/#device-setup","text":"Some devices need to be configured after joining by writing attributes or sending certain commands. This works kind of ok but isn\u2019t robust.","title":"Device setup"},{"location":"modules/fault-tolerance/#ideas","text":"The biggest problem is the \u201cfire and forget\u201d approach. In the case that not all lights in a group react on the press of a remote control button it\u2019s really annoying for the user, pressing a button twice is a workaround but ugly. For fully automated systems this becomes an even larger issue, for example when thermostats are not controlled properly based on schedules or rules, or when light states aren\u2019t set based on schedules (football fields, malls, museums). More and more people having networks with over 100 nodes, here the problems increase.","title":"Ideas"},{"location":"modules/fault-tolerance/#things-we-know","text":"The state a device should have; When sleeping devices wake up event/awake ; The state a device actually has, by reading or reporting ZCL attributes; From a very simplified point of view all we need to do is to remember the state a device should have, verify the actual state and carry out respective commands in case the state isn\u2019t the desired one \u2014 piece of cake \u2014 \u2026 not really but we can get there.","title":"Things we know"},{"location":"modules/fault-tolerance/#possible-generic-approach","text":"In my device description experiments I\u2019ve added a small helper class StateChange which holds one little state machine per logical change. A logical change is something like set on/off, set brightness with transition time, write a ZCL value. High level view: * Multiple StateChange objects can be added to any Resource * The Device class pokes the state machine based on events (rx, polling, timeouts etc.) * A StateChange doesn\u2019t know anything about lights or sensors * It holds only references to ResourceItems which relate to ZCL values * It holds a function pointer to carry out a certain command * It may have an arbitrary long timeout to try to push the change * It is removed from the Resource as soon as the change is finished (verified) or the timeout hits A working very early implementation can be found at: https://github.com/manup/deconz-rest-plugin/commit/08cc3188693757a87008be93c9f2bca80628be60 This commit implements a robust (but lazy) verification of the on/off state of a light resource. Excerpt from PUT /lights/<id>/state const quint8 cmd = taskRef.onTime > 0 ? ONOFF_COMMAND_ON_WITH_TIMED_OFF : ONOFF_COMMAND_ON; ok = addTaskSetOnOff(task, cmd, taskRef.onTime, 0); StateChange change(StateChange::StateWaitSync, SC_SetOnOff, task.req.dstEndpoint()); change.addTargetValue(RStateOn, 0x01); change.addParameter(QLatin1String(\"cmd\"), cmd); if (cmd == ONOFF_COMMAND_ON_WITH_TIMED_OFF) { change.addParameter(QLatin1String(\"ontime\"), taskRef.onTime); } taskRef.lightNode->addStateChange(change); // addStateChange() is inherited from Resource* The SC_SetOnOff is a function pointer which will be called if the state can\u2019t be verified or on timeout. The addTaskSetOnOff() isn\u2019t even needed anymore, but I kept it here to demonstrate that these two can coexist. In future the StateChange or a similar approach is supposed to completely replace the Task based system in order to provide fault tolerance.","title":"Possible generic approach"}]}